// Code generated by protoc-gen-graphql-gateway. DO NOT EDIT.
// source: tarareba.proto

/*
Package tarareba is a reverse proxy.

It translates gRPC into GraphQL.
*/
package tarareba

import (
	"context"

	"github.com/graphql-go/graphql"
	"github.com/grpc-custom/graphql-gateway/runtime"
	"github.com/grpc-custom/graphql-gateway/runtime/cache"

	// "github.com/grpc-custom/graphql-gateway/runtime/errors"
	"github.com/grpc-custom/graphql-gateway/runtime/scalar"
	"golang.org/x/sync/singleflight"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
)

var (
	getCompetitionHistoryRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetCompetitionHistoryRequest",
		Fields: graphql.Fields{
			"userId": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	getCompetitionHistoryResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetCompetitionHistoryResponse",
		Fields: graphql.Fields{
			"isRated": &graphql.Field{
				Type: scalar.Bool,
			},
			"place": &graphql.Field{
				Type: scalar.Uint32,
			},
			"oldRating": &graphql.Field{
				Type: scalar.Uint32,
			},
			"newRating": &graphql.Field{
				Type: scalar.Uint32,
			},
			"performance": &graphql.Field{
				Type: scalar.Uint32,
			},
			"innerPerformance": &graphql.Field{
				Type: scalar.Uint32,
			},
			"contestScreenName": &graphql.Field{
				Type: scalar.String,
			},
			"contestName": &graphql.Field{
				Type: scalar.String,
			},
			"contestNameEn": &graphql.Field{
				Type: scalar.String,
			},
			"endTime": &graphql.Field{
				Type: scalar.Timestamp,
			},
			"isParticipated": &graphql.Field{
				Type: scalar.Bool,
			},
		},
	})
)

func RegisterGQLObjectTypes(mux *runtime.ServeMux) {
}

type tararebaServiceResolver struct {
	client TararebaServiceClient
	group  singleflight.Group
	c      cache.Cache
}

func newTararebaServiceResolver(client TararebaServiceClient) *tararebaServiceResolver {
	return &tararebaServiceResolver{
		client: client,
		group:  singleflight.Group{},
		c:      cache.New(100),
	}
}

func RegisterTararebaServiceFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return
	}
	defer func() {
		if err != nil {
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
		}()
	}()
	return RegisterTararebaServiceHandler(mux, conn)
}

func RegisterTararebaServiceHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterTararebaServiceHandlerClient(mux, NewTararebaServiceClient(conn))
}

func RegisterTararebaServiceHandlerClient(mux *runtime.ServeMux, client TararebaServiceClient) error {
	// svc := newTararebaServiceResolver(client)
	return nil
}
